CCS PCM C Compiler, Version 5.074d, 1               29-ago-17 01:30
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   D:\Google Drive\Educação\UFSC\Graduação Engenharia Elétrica\17.2\Projeto Nível I em Área Básica I (EEL7810)\Projects\First Task C\rafaelalevato.lst

               ROM used:   418 words (20%)
                           Largest free fragment is 1630
               RAM used:   33 (15%) at main() level
                           42 (19%) worst case
               Stack used: 1 locations
               Stack size: 7

*
0000:  NOP
0001:  MOVLW  01
0002:  MOVWF  0A
0003:  GOTO   105
.................... // -------------------------------------------------------------------------------- 
.................... // Disciplina de projeto nivel 1 em area basica 
.................... // Professor Hari Mohr 
.................... // Tarefa 1 - 2017-2 
.................... // Nome: Rafael Pintar Alevato 
....................  
.................... // Fazer um programa que rotacione um led aceso na porta b do kit. 
.................... // Enquanto a chave 1 estiver pressionada ele deve inverter o sentido de rotação. 
.................... // A chave 2 deve aumentar a velocidade de rotação. 
.................... // A chave 3 deve diminuir a velocidade de rotação. 
.................... // A chave 4 alterna o sentido de deslocamento a cada vez que for pressionada. 
.................... // -------------------------------------------------------------------------------- 
....................  
.................... //Carrega a biblioteca para o microcontrolador PIC16F628A 
.................... #include <16F628A.h> 
.................... //////////// Standard Header file for the PIC16F628A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F628A 
0004:  MOVF   3E,W
0005:  XORWF  40,W
0006:  ANDLW  80
0007:  MOVWF  42
0008:  BTFSS  3E.7
0009:  GOTO   00F
000A:  COMF   3D,F
000B:  COMF   3E,F
000C:  INCF   3D,F
000D:  BTFSC  03.2
000E:  INCF   3E,F
000F:  BTFSS  40.7
0010:  GOTO   016
0011:  COMF   3F,F
0012:  COMF   40,F
0013:  INCF   3F,F
0014:  BTFSC  03.2
0015:  INCF   40,F
0016:  MOVLW  10
0017:  MOVWF  41
0018:  CLRF   77
0019:  CLRF   7A
001A:  RRF    3E,F
001B:  RRF    3D,F
001C:  BTFSS  03.0
001D:  GOTO   024
001E:  MOVF   3F,W
001F:  ADDWF  77,F
0020:  BTFSC  03.0
0021:  INCF   7A,F
0022:  MOVF   40,W
0023:  ADDWF  7A,F
0024:  RRF    7A,F
0025:  RRF    77,F
0026:  RRF    79,F
0027:  RRF    78,F
0028:  DECFSZ 41,F
0029:  GOTO   01A
002A:  BTFSS  42.7
002B:  GOTO   031
002C:  COMF   78,F
002D:  COMF   79,F
002E:  INCF   78,F
002F:  BTFSC  03.2
0030:  INCF   79,F
0031:  RETURN
0032:  MOVF   3F,W
0033:  ANDLW  07
0034:  MOVWF  77
0035:  RRF    3F,W
0036:  MOVWF  78
0037:  RRF    78,F
0038:  RRF    78,F
0039:  MOVLW  1F
003A:  ANDWF  78,F
003B:  MOVF   78,W
003C:  ADDWF  41,W
003D:  MOVWF  04
003E:  BCF    03.7
003F:  BTFSC  42.0
0040:  BSF    03.7
0041:  CLRF   78
0042:  INCF   78,F
0043:  INCF   77,F
0044:  GOTO   046
0045:  RLF    78,F
0046:  DECFSZ 77,F
0047:  GOTO   045
0048:  MOVF   40,F
0049:  BTFSC  03.2
004A:  GOTO   04E
004B:  MOVF   78,W
004C:  IORWF  00,F
004D:  GOTO   051
004E:  COMF   78,F
004F:  MOVF   78,W
0050:  ANDWF  00,F
0051:  RETURN
*
008B:  MOVF   40,W
008C:  XORWF  42,W
008D:  ANDLW  80
008E:  MOVWF  44
008F:  BTFSS  40.7
0090:  GOTO   096
0091:  COMF   3F,F
0092:  COMF   40,F
0093:  INCF   3F,F
0094:  BTFSC  03.2
0095:  INCF   40,F
0096:  BTFSS  42.7
0097:  GOTO   09D
0098:  COMF   41,F
0099:  COMF   42,F
009A:  INCF   41,F
009B:  BTFSC  03.2
009C:  INCF   42,F
009D:  CLRF   78
009E:  CLRF   79
009F:  CLRF   77
00A0:  CLRF   7A
00A1:  MOVF   42,W
00A2:  BTFSS  03.2
00A3:  GOTO   0A7
00A4:  MOVF   41,W
00A5:  BTFSC  03.2
00A6:  GOTO   0C1
00A7:  MOVLW  10
00A8:  MOVWF  43
00A9:  BCF    03.0
00AA:  RLF    3F,F
00AB:  RLF    40,F
00AC:  RLF    77,F
00AD:  RLF    7A,F
00AE:  MOVF   42,W
00AF:  SUBWF  7A,W
00B0:  BTFSS  03.2
00B1:  GOTO   0B4
00B2:  MOVF   41,W
00B3:  SUBWF  77,W
00B4:  BTFSS  03.0
00B5:  GOTO   0BD
00B6:  MOVF   41,W
00B7:  SUBWF  77,F
00B8:  BTFSS  03.0
00B9:  DECF   7A,F
00BA:  MOVF   42,W
00BB:  SUBWF  7A,F
00BC:  BSF    03.0
00BD:  RLF    78,F
00BE:  RLF    79,F
00BF:  DECFSZ 43,F
00C0:  GOTO   0A9
00C1:  BTFSS  44.7
00C2:  GOTO   0C8
00C3:  COMF   78,F
00C4:  COMF   79,F
00C5:  INCF   78,F
00C6:  BTFSC  03.2
00C7:  INCF   79,F
....................  
.................... #list 
....................  
....................  
.................... //Configuracao FUSES 
.................... #FUSES NOWDT 
.................... #FUSES INTRC_IO 
.................... #FUSES NOPUT 
.................... #FUSES NOPROTECT 
.................... #FUSES NOBROWNOUT 
.................... #FUSES NOMCLR 
.................... #FUSES NOLVP 
.................... #FUSES NOCPD 
....................  
.................... //Define a utilização do clock interno de 4 Mhz 
.................... #use delay(clock=4000000) 
*
00F0:  MOVLW  3C
00F1:  MOVWF  04
00F2:  BCF    03.7
00F3:  MOVF   00,W
00F4:  BTFSC  03.2
00F5:  GOTO   104
00F6:  MOVLW  01
00F7:  MOVWF  78
00F8:  CLRF   77
00F9:  DECFSZ 77,F
00FA:  GOTO   0F9
00FB:  DECFSZ 78,F
00FC:  GOTO   0F8
00FD:  MOVLW  4A
00FE:  MOVWF  77
00FF:  DECFSZ 77,F
0100:  GOTO   0FF
0101:  GOTO   102
0102:  DECFSZ 00,F
0103:  GOTO   0F6
0104:  RETURN
....................  
.................... #define SIZE_PORT_B 8 
.................... #define DELAY_INTERVAL 25 
.................... #define KEY_1 PIN_A1 
.................... #define KEY_2 PIN_A2 
.................... #define KEY_3 PIN_A3 
.................... #define KEY_4 PIN_A4 
.................... #define PRESSED 0 
.................... #define RELEASED 1 
....................  
.................... void rotatePortB (int16* portB, signed int16 direction); 
....................  
.................... void main() { 
0105:  MOVF   03,W
0106:  ANDLW  1F
0107:  MOVWF  03
0108:  BSF    03.5
0109:  BSF    0E.3
010A:  BCF    03.5
010B:  CLRF   21
010C:  CLRF   20
010D:  MOVLW  07
010E:  MOVWF  1F
010F:  BCF    03.7
*
0128:  MOVLW  FF
0129:  MOVWF  33
012A:  MOVWF  32
012B:  CLRF   35
012C:  MOVLW  01
012D:  MOVWF  34
012E:  CLRF   37
012F:  MOVLW  0A
0130:  MOVWF  36
0131:  BCF    38.0
.................... 	//Declara a PORTB como array. Mais lento, porém utilizado para efeitos didáticos. 
.................... 	int16 portB[] = {PIN_B7, PIN_B6, PIN_B5, PIN_B4, PIN_B3, PIN_B2, PIN_B1, PIN_B0}; 
*
0110:  MOVLW  37
0111:  MOVWF  22
0112:  CLRF   23
0113:  MOVLW  36
0114:  MOVWF  24
0115:  CLRF   25
0116:  MOVLW  35
0117:  MOVWF  26
0118:  CLRF   27
0119:  MOVLW  34
011A:  MOVWF  28
011B:  CLRF   29
011C:  MOVLW  33
011D:  MOVWF  2A
011E:  CLRF   2B
011F:  MOVLW  32
0120:  MOVWF  2C
0121:  CLRF   2D
0122:  MOVLW  31
0123:  MOVWF  2E
0124:  CLRF   2F
0125:  MOVLW  30
0126:  MOVWF  30
0127:  CLRF   31
.................... 	signed int16 direction = -1;	// 1 para esquerda, -1 para direita 
.................... 	signed int16 defaultDirection = 1; 
.................... 	signed int16 delayMultplier = 10; 
.................... 	int1 isKey4Pressed = false; 
....................  
.................... 	while (true) { 
.................... 		if (input(KEY_1) == PRESSED) 
*
0132:  BSF    03.5
0133:  BSF    05.1
0134:  BCF    03.5
0135:  BTFSC  05.1
0136:  GOTO   144
.................... 			direction = defaultDirection*-1; 
0137:  MOVF   35,W
0138:  MOVWF  3E
0139:  MOVF   34,W
013A:  MOVWF  3D
013B:  MOVLW  FF
013C:  MOVWF  40
013D:  MOVWF  3F
013E:  CALL   004
013F:  MOVF   79,W
0140:  MOVWF  33
0141:  MOVF   78,W
0142:  MOVWF  32
0143:  GOTO   148
.................... 		else 
.................... 			direction = defaultDirection; 
0144:  MOVF   35,W
0145:  MOVWF  33
0146:  MOVF   34,W
0147:  MOVWF  32
....................  
.................... 		if (input(KEY_2) == PRESSED) { 
0148:  BSF    03.5
0149:  BSF    05.2
014A:  BCF    03.5
014B:  BTFSC  05.2
014C:  GOTO   155
.................... 			delayMultplier--; 
014D:  MOVF   36,W
014E:  BTFSC  03.2
014F:  DECF   37,F
0150:  DECF   36,F
.................... 			if (delayMultplier < 0) 
0151:  BTFSS  37.7
0152:  GOTO   155
.................... 				delayMultplier = 0; 
0153:  CLRF   37
0154:  CLRF   36
.................... 		} 
....................  
.................... 		if (input(KEY_3) == PRESSED) { 
0155:  BSF    03.5
0156:  BSF    05.3
0157:  BCF    03.5
0158:  BTFSC  05.3
0159:  GOTO   169
.................... 			delayMultplier++; 
015A:  INCF   36,F
015B:  BTFSC  03.2
015C:  INCF   37,F
.................... 			if (delayMultplier > 200) 
015D:  BTFSC  37.7
015E:  GOTO   169
015F:  MOVF   37,F
0160:  BTFSS  03.2
0161:  GOTO   166
0162:  MOVF   36,W
0163:  SUBLW  C8
0164:  BTFSC  03.0
0165:  GOTO   169
.................... 				delayMultplier = 200; 
0166:  CLRF   37
0167:  MOVLW  C8
0168:  MOVWF  36
.................... 		} 
....................  
.................... 		if (input(KEY_4) == PRESSED) { 
0169:  BSF    03.5
016A:  BSF    05.4
016B:  BCF    03.5
016C:  BTFSC  05.4
016D:  GOTO   170
.................... 			isKey4Pressed = true; 
016E:  BSF    38.0
.................... 		} else if (isKey4Pressed) { 
016F:  GOTO   17F
0170:  BTFSS  38.0
0171:  GOTO   17F
.................... 			isKey4Pressed = false; 
0172:  BCF    38.0
.................... 			defaultDirection *= -1; 
0173:  MOVF   35,W
0174:  MOVWF  3E
0175:  MOVF   34,W
0176:  MOVWF  3D
0177:  MOVLW  FF
0178:  MOVWF  40
0179:  MOVWF  3F
017A:  CALL   004
017B:  MOVF   79,W
017C:  MOVWF  35
017D:  MOVF   78,W
017E:  MOVWF  34
.................... 		} 
....................  
.................... 		rotatePortB(portB, direction); 
017F:  CLRF   3A
0180:  MOVLW  22
0181:  MOVWF  39
0182:  MOVF   33,W
0183:  MOVWF  3C
0184:  MOVF   32,W
0185:  MOVWF  3B
0186:  GOTO   052
.................... 		delay_ms(delayMultplier*DELAY_INTERVAL); 
0187:  MOVF   37,W
0188:  MOVWF  3E
0189:  MOVF   36,W
018A:  MOVWF  3D
018B:  CLRF   40
018C:  MOVLW  19
018D:  MOVWF  3F
018E:  CALL   004
018F:  MOVF   79,W
0190:  MOVWF  3A
0191:  MOVF   78,W
0192:  MOVWF  39
0193:  MOVF   3A,W
0194:  MOVWF  3B
0195:  INCF   3B,F
0196:  DECF   3B,F
0197:  BTFSC  03.2
0198:  GOTO   19D
0199:  MOVLW  FF
019A:  MOVWF  3C
019B:  CALL   0F0
019C:  GOTO   196
019D:  MOVF   39,W
019E:  MOVWF  3C
019F:  CALL   0F0
01A0:  GOTO   132
.................... 	} 
.................... 	 
.................... } 
....................  
01A1:  GOTO   1A1
.................... void rotatePortB (int16* portB, signed int16 direction) { 
.................... 	static signed int16 index = 0; 
.................... 	output_bit(portB[index], false); 
*
0052:  MOVF   21,W
0053:  MOVWF  3E
0054:  MOVF   20,W
0055:  MOVWF  3D
0056:  CLRF   40
0057:  MOVLW  02
0058:  MOVWF  3F
0059:  CALL   004
005A:  MOVF   79,W
005B:  MOVWF  7A
005C:  MOVF   78,W
005D:  ADDWF  39,W
005E:  MOVWF  04
005F:  BCF    03.7
0060:  BTFSC  3A.0
0061:  BSF    03.7
0062:  INCF   04,F
0063:  MOVF   00,W
0064:  MOVWF  3E
0065:  DECF   04,F
0066:  MOVF   00,W
0067:  MOVWF  3D
0068:  MOVWF  3F
0069:  CLRF   40
006A:  CLRF   42
006B:  CLRF   41
006C:  CALL   032
006D:  MOVF   3D,W
006E:  MOVWF  3F
006F:  CLRF   40
0070:  CLRF   42
0071:  MOVLW  80
0072:  MOVWF  41
0073:  CALL   032
.................... 	//Calcula o andar pelo array com a função módulo, já criando o rotate 
.................... 	index = (SIZE_PORT_B + (index + direction)) % SIZE_PORT_B; 
0074:  MOVF   3B,W
0075:  ADDWF  20,W
0076:  MOVWF  78
0077:  MOVF   21,W
0078:  MOVWF  7A
0079:  MOVF   3C,W
007A:  BTFSC  03.0
007B:  INCFSZ 3C,W
007C:  ADDWF  7A,F
007D:  MOVF   78,W
007E:  ADDLW  08
007F:  MOVWF  3D
0080:  MOVF   7A,W
0081:  MOVWF  3E
0082:  BTFSC  03.0
0083:  INCF   3E,F
0084:  MOVF   3E,W
0085:  MOVWF  40
0086:  MOVF   3D,W
0087:  MOVWF  3F
0088:  CLRF   42
0089:  MOVLW  08
008A:  MOVWF  41
*
00C8:  MOVF   77,W
00C9:  MOVWF  20
00CA:  MOVF   7A,W
00CB:  MOVWF  21
.................... 	output_bit(portB[index], true); 
00CC:  MOVF   21,W
00CD:  MOVWF  3E
00CE:  MOVF   20,W
00CF:  MOVWF  3D
00D0:  CLRF   40
00D1:  MOVLW  02
00D2:  MOVWF  3F
00D3:  CALL   004
00D4:  MOVF   79,W
00D5:  MOVWF  7A
00D6:  MOVF   78,W
00D7:  ADDWF  39,W
00D8:  MOVWF  04
00D9:  BCF    03.7
00DA:  BTFSC  3A.0
00DB:  BSF    03.7
00DC:  INCF   04,F
00DD:  MOVF   00,W
00DE:  MOVWF  3E
00DF:  DECF   04,F
00E0:  MOVF   00,W
00E1:  MOVWF  3D
00E2:  MOVWF  3F
00E3:  MOVLW  01
00E4:  MOVWF  40
00E5:  CLRF   42
00E6:  CLRF   41
00E7:  CALL   032
00E8:  MOVF   3D,W
00E9:  MOVWF  3F
00EA:  CLRF   40
00EB:  CLRF   42
00EC:  MOVLW  80
00ED:  MOVWF  41
00EE:  CALL   032
00EF:  GOTO   187 (RETURN)
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F18   NOWDT NOPUT INTRC_IO NOMCLR NOBROWNOUT NOLVP NOCPD NOPROTECT

   Some fuses have been forced to be compatible with the ICD debugger.
